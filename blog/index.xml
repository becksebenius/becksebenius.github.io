<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Beck Sebenius</title>
    <link>https://becksebenius.github.io/blog/</link>
    <description>Recent content in Blog on Beck Sebenius</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 22 Aug 2015 06:42:21 -0700</lastBuildDate>
    
	<atom:link href="https://becksebenius.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Feature Summary: Iterators in C#</title>
      <link>https://becksebenius.github.io/blog/feature-summary-iterators-in-csharp/</link>
      <pubDate>Mon, 25 Dec 2017 13:34:25 -0700</pubDate>
      
      <guid>https://becksebenius.github.io/blog/feature-summary-iterators-in-csharp/</guid>
      <description>When programming with any language, it&amp;rsquo;s important to know the full suite of tools, their caveats, and their hidden benefits. A tool in C# that often goes overlooked are enumerables, and their spouse the iterators (called enumerators in C#). These tools are incredibly powerful and can make code more concise and flexible, but can also end up causing some serious problems down the line.
First, lets establish some terms:</description>
    </item>
    
    <item>
      <title>Coroutine Sequencing and Scriptable Objects</title>
      <link>https://becksebenius.github.io/blog/coroutine-sequencing-and-scriptable-objects/</link>
      <pubDate>Sun, 02 Sep 2012 04:05:25 -0600</pubDate>
      
      <guid>https://becksebenius.github.io/blog/coroutine-sequencing-and-scriptable-objects/</guid>
      <description>Here&amp;rsquo;s some code snippets that I&amp;rsquo;ve started using quite a bit in my projects. Neither of them are terribly complex, but hopefully someone finds them useful! First is the IEnumerator Queue. This one is used for sequencing coroutines together.
using System.Collections; using System.Collections.Generic; public class CoroutineQueue : Queue &amp;lt; IEnumerator &amp;gt; ; { public IEnumerator current; public CoroutineQueue () {} public CoroutineQueue (params IEnumerator[] startingIEnumerators) { foreach(IEnumerator i in startingIEnumerators) Enqueue(i); } public void Update () { if(current !</description>
    </item>
    
    <item>
      <title>Custom Editors in Unity3d</title>
      <link>https://becksebenius.github.io/blog/custom-editors-in-unity3d/</link>
      <pubDate>Thu, 26 Jul 2012 04:05:25 -0600</pubDate>
      
      <guid>https://becksebenius.github.io/blog/custom-editors-in-unity3d/</guid>
      <description>Unity&amp;rsquo;s built-in serialized data viewer - the default component inspector - is very useful for managing the behaviors of your Unity game. However, there comes a point when a project&amp;rsquo;s complexity becomes too deep to manage with this simple browser. Data cannot be moved or contain persistent relationships, and it is impossible to run functions on your code from within the editor using the default tools. This is why the Unity Editor scripting interface is incredibly powerful, and learning to use it has been one of the most influential factors in improving my workflow.</description>
    </item>
    
  </channel>
</rss>